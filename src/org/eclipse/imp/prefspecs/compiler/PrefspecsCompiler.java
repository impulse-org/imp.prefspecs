package org.eclipse.imp.prefspecs.compiler;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.imp.builder.MarkerCreator;
import org.eclipse.imp.model.ISourceProject;
import org.eclipse.imp.model.ModelFactory;
import org.eclipse.imp.model.ModelFactory.ModelException;
import org.eclipse.imp.parser.IParseController;
import org.eclipse.imp.preferences.ISafariPreferencesService;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteBooleanFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteStringFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.PreferencesPageInfo;
import org.eclipse.imp.prefspecs.pageinfo.PreferencesTabInfo;
import org.eclipse.imp.prefspecs.pageinfo.VirtualBooleanFieldInfo;
import org.eclipse.imp.prefspecs.parser.PrefspecsParseController;
import org.eclipse.imp.prefspecs.parser.Ast.ASTNode;
import org.eclipse.imp.prefspecs.parser.Ast.AbstractVisitor;
import org.eclipse.imp.prefspecs.parser.Ast.IstringEmptySpec;
import org.eclipse.imp.prefspecs.parser.Ast.booleanDefValueSpec;
import org.eclipse.imp.prefspecs.parser.Ast.booleanFieldPropertySpecs;
import org.eclipse.imp.prefspecs.parser.Ast.booleanFieldSpec;
import org.eclipse.imp.prefspecs.parser.Ast.booleanSpecialSpec;
import org.eclipse.imp.prefspecs.parser.Ast.configurationTabSpec;
import org.eclipse.imp.prefspecs.parser.Ast.customRule;
import org.eclipse.imp.prefspecs.parser.Ast.defaultTabSpec;
import org.eclipse.imp.prefspecs.parser.Ast.generalSpecs;
import org.eclipse.imp.prefspecs.parser.Ast.instanceTabSpec;
import org.eclipse.imp.prefspecs.parser.Ast.isEditableSpec;
import org.eclipse.imp.prefspecs.parser.Ast.isRemovableSpec;
import org.eclipse.imp.prefspecs.parser.Ast.pageSpec;
import org.eclipse.imp.prefspecs.parser.Ast.projectTabSpec;
import org.eclipse.imp.prefspecs.parser.Ast.stringDefValueSpec;
import org.eclipse.imp.prefspecs.parser.Ast.stringEmptySpec0;
import org.eclipse.imp.prefspecs.parser.Ast.stringEmptySpec1;
import org.eclipse.imp.prefspecs.parser.Ast.stringFieldPropertySpecs;
import org.eclipse.imp.prefspecs.parser.Ast.stringFieldSpec;
import org.eclipse.imp.prefspecs.parser.Ast.stringSpecialSpec;
import org.eclipse.imp.prefspecs.parser.PrefspecsParser.SymbolTable;

public class PrefspecsCompiler {
    private static final String sClassNameMacro= "$FILE$";

    private static final String sTemplateHeader= "public class " + sClassNameMacro + " {\n" +
        "\tpublic static void main(String[] args) {\n" +
        "\t\tnew " + sClassNameMacro + "().main();\n" +
        "\t\tSystem.out.println(\"done.\");\n" +
        "\t}\n";

    private static final String sTemplateFooter= "}\n";

    //Stack/*<String>*/ fTranslationStack= new Stack();
    
    //public static final String PROBLEM_MARKER_ID= PrefspecsPlugin.kPluginID + ".$PROBLEM_ID$";
    public String PROBLEM_MARKER_ID;
    
    public PrefspecsCompiler(String problem_marker_id) {
    	PROBLEM_MARKER_ID = problem_marker_id;
    }
    
    
    // SMS 4 May 2007:  Intermediate representation generated by compiler
    protected PreferencesPageInfo pageInfo = null;
    
    public PreferencesPageInfo getPreferencesPageInfo() {
    	return pageInfo;
    }
    
    
    private final class TranslatorVisitor extends AbstractVisitor {
    	SymbolTable innerScope;

        public void unimplementedVisitor(String s) {
            // System.err.println("Don't know how to translate node type '" + s + "'.");
        }
        
        public boolean visit(pageSpec p) {
        	pageInfo = new PreferencesPageInfo(p.getidentifier().toString());
        	return true;
        }
        
        public void endVisit(pageSpec p) {
        	pageInfo.dump();
        }
        
        
        public boolean visit(defaultTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getDEFAULT().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();

        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
        		try {
        			tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        		} catch (IllegalArgumentException e) {
        			System.err.println("PrefspecsCompiler.TranslatorVisitor.visit(defaultTabSpec:  \n" +
        					"\tattempt to set isRemovable to illegal value 'true'; substituting 'false'.");
        			tab.setIsRemovable(false);
        		}
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
        
        
        public boolean visit(configurationTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getCONFIGURATION
        			().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();

        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
  
        
        public boolean visit(instanceTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getINSTANCE().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();

        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        

        public boolean visit(projectTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getPROJECT().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();
        	
        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
        
        
        public boolean visit(booleanFieldSpec boolField) {
        	VirtualBooleanFieldInfo vBool = new VirtualBooleanFieldInfo(pageInfo, boolField.getidentifier().toString());
        	booleanFieldPropertySpecs propSpecs = boolField.getbooleanFieldPropertySpecs();
        	
        	// Create a virtual field
            isEditableSpec editableSpec = propSpecs.getgeneralSpecs().getisEditableSpec();
        	if (editableSpec != null) {
        		vBool.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getgeneralSpecs().getisRemovableSpec();
        	if (removableSpec != null) {
            	vBool.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	booleanSpecialSpec specialSpec = propSpecs.getbooleanSpecificSpec().getbooleanCustomSpec();
        	// hasSpecial <==> specialSpec != null (i.e., presence of spec indicates true)
        	if (specialSpec != null) {
        		vBool.setHasSpecial(true);
            	vBool.setSpecial(specialSpec.getbooleanValue().toString().equals("true"));
        	} else {
        		vBool.setHasSpecial(false);
        		vBool.setSpecial(false);
        	}

        	booleanDefValueSpec defValueSpec = propSpecs.getbooleanSpecificSpec().getbooleanDefValueSpec();
        	if (defValueSpec != null) {
        		vBool.setDefaultValue(defValueSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	
        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = pageInfo.getTabInfos();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteBooleanFieldInfo cBool = new ConcreteBooleanFieldInfo(vBool, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cBool.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(ISafariPreferencesService.DEFAULT_LEVEL))) {
                	cBool.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cBool.setHasSpecial(true);
                	cBool.setSpecial(specialSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setHasSpecial(false);
            		cBool.setSpecial(false);
            	}
        	}
        	return false;
        }
        
        
        
        public boolean visit(stringFieldSpec stringField) {
        	VirtualStringFieldInfo vString = new VirtualStringFieldInfo(pageInfo, stringField.getidentifier().toString());
        	stringFieldPropertySpecs propSpecs = stringField.getstringFieldPropertySpecs();
        	
        	// Create a virtual field
            isEditableSpec editableSpec = propSpecs.getgeneralSpecs().getisEditableSpec();
        	if (editableSpec != null) {
        		vString.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getgeneralSpecs().getisRemovableSpec();
        	if (removableSpec != null) {
            	vString.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	stringSpecialSpec specialSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringSpecialSpec();
        	// hasSpecial <==> specialSpec != null (i.e., presence of spec indicates true)
        	if (specialSpec != null) {
        		vString.setHasSpecial(true);
            	vString.setSpecial(specialSpec.getstringValue().getSTRING_LITERAL().toString());
        	} else {
        		vString.setHasSpecial(false);
        		vString.setSpecial(null);
        	}

        	stringDefValueSpec defValueSpec = propSpecs.getstringSpecificSpec().getstringDefValueSpec();
        	if (defValueSpec != null) {
        		vString.setDefValue(defValueSpec.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	IstringEmptySpec emptyValueSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringEmptySpec();
        	if (emptyValueSpec instanceof stringEmptySpec0) {
        		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
        		vString.setEmptyValueAllowed(false);
        		vString.setEmptyValue(null);
        	} else if (emptyValueSpec instanceof stringEmptySpec1) {
           		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
        		vString.setEmptyValueAllowed(ses1.getEMPTYALLOWED().toString().equals("true"));
        		vString.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = pageInfo.getTabInfos();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteStringFieldInfo cString = new ConcreteStringFieldInfo(vString, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cString.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cString.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(ISafariPreferencesService.DEFAULT_LEVEL))) {
                	cString.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cString.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cString.setHasSpecial(true);
                	cString.setSpecial(specialSpec.getstringValue().getSTRING_LITERAL().toString());
            	} else {
            		cString.setHasSpecial(false);
            		cString.setSpecial(null);
            	}
            	if (emptyValueSpec != null) {
	            	if (emptyValueSpec instanceof stringEmptySpec0) {
	            		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
	            		cString.setEmptyValueAllowed(false);
	            		cString.setEmptyValue(null);
	            	} else if (emptyValueSpec instanceof stringEmptySpec1) {
	               		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
	            		cString.setEmptyValueAllowed(true);
	            		cString.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
	            	}
            	}
        	}
        	return false;
        }
        
        
        
        
        /*
         * Context for processing of custom rules 
         */ 
        String customTabName = null;
        PreferencesTabInfo customTabInfo = null;
        String customFieldName = null;
        ConcreteFieldInfo customFieldInfo = null;
        
        
        public boolean visit(customRule custRule)
        {
        	// Set context for custom spec processing
        	customTabName = custRule.gettab().toString();
        	customFieldName = custRule.getidentifier().toString();
        	
        	customTabInfo = pageInfo.getTabInfo(customTabName);
        	Iterator concreteFields = customTabInfo.getConcreteFields();
        	// Should always have a field with the given name
        	while (concreteFields.hasNext()) {
        		ConcreteFieldInfo next = (ConcreteFieldInfo) concreteFields.next();
        		if (next.getName().equals(customFieldName)) {
        			customFieldInfo = next;
        			break;
        		}	
        	}
        	if (customFieldInfo == null) {
        		// What to do?  Seems that specification is erroneous
        		System.err.println("PrefspecsCompiler.TranslatorVisitor.visit(customRule):\n    found no field info corresponding to field name = '" +
        				customFieldName + "';\n    continuing at your own risk");
        	}
        	
        	return true;
        }
        
        
        public void endVisit(customRule custRule)
        {
        	// Reset context of custom spec processing
        	customTabName = null;
        	customTabInfo = null;
        	customFieldName = null;
        	customFieldInfo = null;	
        }
        

        // Use endVisit(..) methods to get information from specs because when
        // visit(..)ed they don't yet have the info that's needed
        
        
        public void endVisit(generalSpecs genSpecs)
        {
        	// Process general spec as part of a custom rule,
        	// if processing a custom rule
        	if (customTabName != null) {
        		if (genSpecs.getisEditableSpec() != null)
	        		customFieldInfo.setIsEditable(genSpecs.getisEditableSpec().getbooleanValue().toString().equals("true"));
        		try {
        			if (genSpecs.getisRemovableSpec() != null)
        				customFieldInfo.setIsRemovable(genSpecs.getisRemovableSpec().getbooleanValue().toString().equals("true"));
        		} catch (IllegalArgumentException e) {
        			System.err.println("PrefspecsCompiler.TranslatorVisitor.visit(generalSpecs:  \n" +
        					"\tattempt to set isRemovable to illegal value 'true'; substituting 'false'.");
        			customFieldInfo.setIsRemovable(false);
        		}
        	}
        }
        
        
        public void endVisit(booleanSpecialSpec specialSpec)
        {
        	// Process special spec as part of a boolean custom spec,
        	// if processing a custom rule
        	// If the specialSpec is not null, then the field has a special spec
        	// and the value of that spec is the special value for the field
        	if (customTabName != null) {
        		// Don't think the boolean value can be null if we have a specialSpec	
        		((ConcreteBooleanFieldInfo)customFieldInfo).setSpecial(specialSpec.getbooleanValue().toString().equals("true"));
        	}
        }
        
        
        public void endVisit(stringSpecialSpec specialSpec)
        {
        	// Process special spec as part of a string custom spec,
        	// if processing a custom rule
        	// If the specialSpec is not null, then the field has a special spec
        	// and the value of that spec is the special value for the field
        	if (customTabName != null) {
        		// Don't think the boolean value can be null if we have a specialSpec	
        		((ConcreteStringFieldInfo)customFieldInfo).setSpecial(specialSpec.getstringValue().getSTRING_LITERAL().toString());
        	}
        }
        

        
    }

    
    
    public PrefspecsCompiler() {
        super();
    }

    public String getFileContents(IFile file) {
        char[] buf= null;
        try {
            File javaFile= new File(file.getLocation().toOSString());
            FileReader fileReader= new FileReader(javaFile);
            int len= (int) javaFile.length();

            buf= new char[len];
            fileReader.read(buf, 0, len);
            return new String(buf);
        } catch(FileNotFoundException fnf) {
            System.err.println(fnf.getMessage());
            return "";
        } catch(IOException io) {
            System.err.println(io.getMessage());
            return "";
        }
    }

    public PreferencesPageInfo compile(IFile file, IProgressMonitor mon) {
       	
    	if (file == null) {
            System.err.println("PrefspecsCompiler.compile(..):  returning null");
    		return null;
    	}
    	IProject project= file.getProject();
    	if (project == null) {
            System.err.println("PrefspecsCompiler.compile(..):  Project is null; returning null");
    		return null;
    	}
		ISourceProject sourceProject = null;
    	try {
    		sourceProject = ModelFactory.open(project);
    	} catch (ModelException me){
            System.err.println("PrefspecsCompiler.compile(..):  Model exception:\n" + me.getMessage() + "\nReturning null");
            return null;
    	}
        IParseController parseController= new PrefspecsParseController();
        
        // Marker creator handles error messages from the parse controller
        MarkerCreator markerCreator = new MarkerCreator(file, parseController, PROBLEM_MARKER_ID);

        // If we have a kind of parser that might be receptive, tell it
        // what types of problem marker the builder will create
        parseController.addProblemMarkerType(PROBLEM_MARKER_ID);
        
        parseController.initialize(file.getProjectRelativePath(), sourceProject, markerCreator);

        parseController.parse(getFileContents(file), false, mon);

        ASTNode currentAst= (ASTNode) parseController.getCurrentAst();

        if (currentAst == null) {
            System.err.println("PrefspecsCompiler.compile:  current AST is null (parse errors?); unable to compile.");
        	return null;
        }

        String fileExten= file.getFileExtension();
        String fileBase= file.getName().substring(0, file.getName().length() - fileExten.length() - 1);

        TranslatorVisitor visitor = new TranslatorVisitor();
        
        currentAst.accept(visitor);

        return pageInfo;

    }
    
    public PreferencesPageInfo getPageInfo(IFile file, IProgressMonitor mon) {

       	if (file == null) {
            System.err.println("PrefspecsCompiler.getPageInfo(..):  returning null");
    		return null;
    	}
    	IProject project= file.getProject();
    	if (project == null) {
            System.err.println("PrefspecsCompiler.getPageInfo(..):  Project is null; returning null");
    		return null;
    	}
		ISourceProject sourceProject = null;
    	try {
    		sourceProject = ModelFactory.open(project);
    	} catch (ModelException me){
            System.err.println("PrefspecsCompiler.getPageInfo(..):  Model exception:\n" + me.getMessage() + "\nReturning null");
            return null;
    	}
        IParseController parseController= new PrefspecsParseController();
        
        // Marker creator handles error messages from the parse controller
        MarkerCreator markerCreator = new MarkerCreator(file, parseController, PROBLEM_MARKER_ID);

        // If we have a kind of parser that might be receptive, tell it
        // what types of problem marker the builder will create
        parseController.addProblemMarkerType(PROBLEM_MARKER_ID);
        
        parseController.initialize(file.getProjectRelativePath(), sourceProject, markerCreator);
    	
    	parseController.parse(getFileContents(file), false, mon);

        ASTNode currentAst= (ASTNode) parseController.getCurrentAst();

        if (currentAst == null) {
            System.err.println("PrefspecsCompiler.getPageInfo	:  current AST is null (parse errors?); unable to compile.");
        	return null;
        }

        String fileExten= file.getFileExtension();
        String fileBase= file.getName().substring(0, file.getName().length() - fileExten.length() - 1);

        TranslatorVisitor translatorVisitor = new TranslatorVisitor();
        currentAst.accept(translatorVisitor);

        return getPreferencesPageInfo();
        
    }
}
