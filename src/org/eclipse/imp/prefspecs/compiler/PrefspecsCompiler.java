package prefspecs.safari.compiler;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Iterator;
import java.util.Stack;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.ui.internal.IPreferenceConstants;
import org.eclipse.uide.builder.MarkerCreator;
import org.eclipse.uide.parser.IParseController;
import org.eclipse.uide.parser.IParseControllerWithMarkerTypes;
import org.eclipse.uide.preferences.ISafariPreferencesService;

import prefspecs.safari.parser.PrefspecsParseController;
import prefspecs.safari.parser.Ast.ASTNode;
import prefspecs.safari.parser.Ast.AbstractVisitor;
import prefspecs.safari.parser.Ast.booleanFieldPropertySpecs;
import prefspecs.safari.parser.Ast.booleanFieldSpec;
import prefspecs.safari.parser.Ast.booleanSpecialSpec;
import prefspecs.safari.parser.Ast.configurationTabSpec;
import prefspecs.safari.parser.Ast.defaultTabSpec;
import prefspecs.safari.parser.Ast.instanceTabSpec;
import prefspecs.safari.parser.Ast.isEditableSpec;
import prefspecs.safari.parser.Ast.isRemovableSpec;
import prefspecs.safari.parser.Ast.pageSpec;
import prefspecs.safari.parser.Ast.projectTabSpec;
import prefspecs.safari.parser.Ast.tabPropertySpecs;
import prefspecs.safari.parser.PrefspecsParser.SymbolTable;

public class PrefspecsCompiler {
    private static final String sClassNameMacro= "$FILE$";

    private static final String sTemplateHeader= "public class " + sClassNameMacro + " {\n" +
        "\tpublic static void main(String[] args) {\n" +
        "\t\tnew " + sClassNameMacro + "().main();\n" +
        "\t\tSystem.out.println(\"done.\");\n" +
        "\t}\n";

    private static final String sTemplateFooter= "}\n";

    Stack/*<String>*/ fTranslationStack= new Stack();
    
    //public static final String PROBLEM_MARKER_ID= PrefspecsPlugin.kPluginID + ".$PROBLEM_ID$";
    public String PROBLEM_MARKER_ID;
    
    public PrefspecsCompiler(String problem_marker_id) {
    	PROBLEM_MARKER_ID = problem_marker_id;
    }
    
    
    // SMS 4 May 2007:  Intermediate representation
    // first generated by compiler
    private PreferencesPageInfo prefsPage = null;
    
    public PreferencesPageInfo getPreferencesPageInfo() {
    	return prefsPage;
    }
    
    
    private final class TranslatorVisitor extends AbstractVisitor {
    	SymbolTable innerScope;

        public void unimplementedVisitor(String s) {
            // System.err.println("Don't know how to translate node type '" + s + "'.");
        }
        
        public boolean visit(pageSpec p) {
        	prefsPage = new PreferencesPageInfo(p.getidentifier().toString());
        	return true;
        }
        
        public void endVisit(pageSpec p) {
        	prefsPage.dump();
        }
        
        
        public boolean visit(defaultTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(prefsPage, tabSpec.getDEFAULT().toString());
        	tabPropertySpecs propSpecs = tabSpec.gettabPropertySpecs();

        	
        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
        
        
        public boolean visit(configurationTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(prefsPage, tabSpec.getCONFIGURATION
        			().toString());
        	tabPropertySpecs propSpecs = tabSpec.gettabPropertySpecs();

        	
        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
  
        
        public boolean visit(instanceTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(prefsPage, tabSpec.getINSTANCE().toString());
        	tabPropertySpecs propSpecs = tabSpec.gettabPropertySpecs();

        	
        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
       
        public boolean visit(projectTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(prefsPage, tabSpec.getPROJECT().toString());
        	tabPropertySpecs propSpecs = tabSpec.gettabPropertySpecs();

        	
        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
        
        
        public boolean visit(booleanFieldSpec boolField) {
        	VirtualBooleanFieldInfo vBool = new VirtualBooleanFieldInfo(prefsPage, boolField.getidentifier().toString());
        	booleanFieldPropertySpecs propSpecs = boolField.getbooleanFieldPropertySpecs();
        	
            isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		vBool.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	vBool.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	booleanSpecialSpec specialSpec = propSpecs.getbooleanSpecialSpec();
        	if (specialSpec != null) {
        		vBool.setHasSpecial(true);
            	vBool.setSpecial(specialSpec.getbooleanValue().toString().equals("true"));
        	}

        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = prefsPage.getTabs();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteBooleanFieldInfo cBool = new ConcreteBooleanFieldInfo(vBool, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cBool.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(ISafariPreferencesService.DEFAULT_LEVEL))) {
                	cBool.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cBool.setHasSpecial(true);
                	cBool.setSpecial(specialSpec.getbooleanValue().toString().equals("true"));
            	}		
        	}
        	return false;
        }
        
    }

    
    
    public PrefspecsCompiler() {
        super();
    }

    public String getFileContents(IFile file) {
        char[] buf= null;
        try {
            File javaFile= new File(file.getLocation().toOSString());
            FileReader fileReader= new FileReader(javaFile);
            int len= (int) javaFile.length();

            buf= new char[len];
            fileReader.read(buf, 0, len);
            return new String(buf);
        } catch(FileNotFoundException fnf) {
            System.err.println(fnf.getMessage());
            return "";
        } catch(IOException io) {
            System.err.println(io.getMessage());
            return "";
        }
    }

    public void compile(IFile file, IProgressMonitor mon) {
        IProject project= file.getProject();
        IParseController parseController= new PrefspecsParseController();
        
        // Marker creator handles error messages from the parse controller
        MarkerCreator markerCreator = new MarkerCreator(file, parseController, PROBLEM_MARKER_ID);

        // If we have a kind of parser that might be receptive, tell it
        // what types of problem marker the builder will create
        if (parseController instanceof IParseControllerWithMarkerTypes) {
            ((IParseControllerWithMarkerTypes)parseController).addProblemMarkerType(PROBLEM_MARKER_ID);
        }
        
        parseController.initialize(file.getProjectRelativePath()/*.toString()*/, project, markerCreator);
        parseController.parse(getFileContents(file), false, mon);

        ASTNode currentAst= (ASTNode) parseController.getCurrentAst();

        if (currentAst == null) {
            System.err.println("PrefspecsCompiler.compile:  current AST is null (parse errors?); unable to compile.");
        	return;
        }

        String fileExten= file.getFileExtension();
        String fileBase= file.getName().substring(0, file.getName().length() - fileExten.length() - 1);

        currentAst.accept(new TranslatorVisitor());

//        IFile javaFile= project.getFile(file.getProjectRelativePath().removeFileExtension().addFileExtension("java"));
//        String javaSource= sTemplateHeader.replaceAll(sClassNameMacro.replaceAll("\\$", "\\\\\\$"), fileBase) + fTranslationStack.pop() + sTemplateFooter;
//        ByteArrayInputStream bais = new ByteArrayInputStream(javaSource.getBytes());
//
//        try {
//            if (!javaFile.exists())
//                javaFile.create(bais, true, mon);
//            else
//                javaFile.setContents(bais, true, false, mon);
//        } catch (CoreException ce) {
//            System.err.println(ce.getMessage());
//        }
    }
    
    public PreferencesPageInfo getPageInfo(IFile file, IProgressMonitor mon) {
        IProject project= file.getProject();
        IParseController parseController= new PrefspecsParseController();
        
        // Marker creator handles error messages from the parse controller
        MarkerCreator markerCreator = new MarkerCreator(file, parseController, PROBLEM_MARKER_ID);

        // If we have a kind of parser that might be receptive, tell it
        // what types of problem marker the builder will create
        if (parseController instanceof IParseControllerWithMarkerTypes) {
            ((IParseControllerWithMarkerTypes)parseController).addProblemMarkerType(PROBLEM_MARKER_ID);
        }
        
        parseController.initialize(file.getProjectRelativePath()/*.toString()*/, project, markerCreator);
        parseController.parse(getFileContents(file), false, mon);

        ASTNode currentAst= (ASTNode) parseController.getCurrentAst();

        if (currentAst == null) {
            System.err.println("PrefspecsCompiler.getPageInfo	:  current AST is null (parse errors?); unable to compile.");
        	return null;
        }

        String fileExten= file.getFileExtension();
        String fileBase= file.getName().substring(0, file.getName().length() - fileExten.length() - 1);

        TranslatorVisitor translatorVisitor = new TranslatorVisitor();
        currentAst.accept(translatorVisitor);

        return getPreferencesPageInfo();
        
    }
}
