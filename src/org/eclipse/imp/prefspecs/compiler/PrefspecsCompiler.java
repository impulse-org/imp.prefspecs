/*
 * (C) Copyright IBM Corporation 2007
 * 
 * This file is part of the Eclipse IMP.
 */
package org.eclipse.imp.prefspecs.compiler;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.imp.builder.MarkerCreator;
import org.eclipse.imp.model.ISourceProject;
import org.eclipse.imp.model.ModelFactory;
import org.eclipse.imp.model.ModelFactory.ModelException;
import org.eclipse.imp.parser.IParseController;
import org.eclipse.imp.preferences.IPreferencesService;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteBooleanFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteDirListFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteFileFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteIntFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.ConcreteStringFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.PreferencesPageInfo;
import org.eclipse.imp.prefspecs.pageinfo.PreferencesTabInfo;
import org.eclipse.imp.prefspecs.pageinfo.VirtualBooleanFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.VirtualDirListFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.VirtualFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.VirtualFileFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.VirtualIntFieldInfo;
import org.eclipse.imp.prefspecs.pageinfo.VirtualStringFieldInfo;
import org.eclipse.imp.prefspecs.parser.PrefspecsParseController;
import org.eclipse.imp.prefspecs.parser.Ast.*;
import org.eclipse.imp.prefspecs.parser.PrefspecsParser.SymbolTable;

public class PrefspecsCompiler {
    private static final String sClassNameMacro= "$FILE$";

    private static final String sTemplateHeader= "public class " + sClassNameMacro + " {\n" +
        "\tpublic static void main(String[] args) {\n" +
        "\t\tnew " + sClassNameMacro + "().main();\n" +
        "\t\tSystem.out.println(\"done.\");\n" +
        "\t}\n";

    private static final String sTemplateFooter= "}\n";

    //Stack/*<String>*/ fTranslationStack= new Stack();
    
    //public static final String PROBLEM_MARKER_ID= PrefspecsPlugin.kPluginID + ".$PROBLEM_ID$";
    public String PROBLEM_MARKER_ID;
    
    public PrefspecsCompiler(String problem_marker_id) {
    	PROBLEM_MARKER_ID = problem_marker_id;
    }
    
    
    // SMS 4 May 2007:  Intermediate representation generated by compiler
    protected PreferencesPageInfo pageInfo = null;
    
    public PreferencesPageInfo getPreferencesPageInfo() {
    	return pageInfo;
    }
    
    
    private final class TranslatorVisitor extends AbstractVisitor {
    	SymbolTable innerScope;

        public void unimplementedVisitor(String s) {
            // System.err.println("Don't know how to translate node type '" + s + "'.");
        }
        
        public boolean visit(pageSpec p) {
        	pageInfo = new PreferencesPageInfo(p.getidentifier().toString());
        	return true;
        }
        
        public void endVisit(pageSpec p) {
        	pageInfo.dump();
        }
        
        
        public boolean visit(defaultTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getDEFAULT().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();

        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
        		try {
        			tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        		} catch (IllegalArgumentException e) {
        			System.err.println("PrefspecsCompiler.TranslatorVisitor.visit(defaultTabSpec:  \n" +
        					"\tattempt to set isRemovable to illegal value 'true'; substituting 'false'.");
        			tab.setIsRemovable(false);
        		}
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
        
        
        public boolean visit(configurationTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getCONFIGURATION
        			().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();

        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
  
        
        public boolean visit(instanceTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getINSTANCE().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();

        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        

	public boolean visit(projectTabSpec tabSpec) {
        	PreferencesTabInfo tab = new PreferencesTabInfo(pageInfo, tabSpec.getPROJECT().toString());
        	generalSpecs propSpecs = tabSpec.getgeneralSpecs();
        	
        	isEditableSpec editableSpec = propSpecs.getisEditableSpec();
        	if (editableSpec != null) {
        		tab.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getisRemovableSpec();
        	if (removableSpec != null) {
            	tab.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	// Should always have an inout spec
        	tab.setIsUsed(tabSpec.getinout().toString().equals("in"));
        	return false;
        }
        
        
        
        public boolean visit(booleanFieldSpec boolField) {
        	VirtualBooleanFieldInfo vBool = new VirtualBooleanFieldInfo(pageInfo, boolField.getidentifier().toString());
        	booleanFieldPropertySpecs propSpecs = boolField.getbooleanFieldPropertySpecs();
        	
        	// Create a virtual field
            isEditableSpec editableSpec = propSpecs.getgeneralSpecs().getisEditableSpec();
        	if (editableSpec != null) {
        		vBool.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getgeneralSpecs().getisRemovableSpec();
        	if (removableSpec != null) {
            	vBool.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	booleanSpecialSpec specialSpec = propSpecs.getbooleanSpecificSpec().getbooleanCustomSpec();
        	// hasSpecial <==> specialSpec != null (i.e., presence of spec indicates true)
        	if (specialSpec != null) {
        		vBool.setHasSpecialValue(true);
            	vBool.setSpecialValue(specialSpec.getbooleanValue().toString().equals("true"));
        	} else {
        		vBool.setHasSpecialValue(false);
        		//vBool.setSpecialValue(false);
        	}

        	booleanDefValueSpec defValueSpec = propSpecs.getbooleanSpecificSpec().getbooleanDefValueSpec();
        	if (defValueSpec != null) {
        		vBool.setDefaultValue(defValueSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	
        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = pageInfo.getTabInfos();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteBooleanFieldInfo cBool = new ConcreteBooleanFieldInfo(vBool, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cBool.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(IPreferencesService.DEFAULT_LEVEL))) {
                	cBool.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cBool.setHasSpecialValue(true);
                	cBool.setSpecialValue(specialSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cBool.setHasSpecialValue(false);
            		//cBool.setSpecialValue(false);
            	}
        	}
        	return false;
        }
        
        
        public boolean visit(dirListFieldSpec dirListField) {
        	VirtualDirListFieldInfo vDirList = new VirtualDirListFieldInfo(pageInfo, dirListField.getidentifier().toString());
        	dirlistFieldPropertySpecs propSpecs = dirListField.getdirlistFieldPropertySpecs();
        	
        	// Create a virtual field
            isEditableSpec editableSpec = propSpecs.getgeneralSpecs().getisEditableSpec();
        	if (editableSpec != null) {
        		vDirList.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getgeneralSpecs().getisRemovableSpec();
        	if (removableSpec != null) {
            	vDirList.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	stringSpecialSpec specialSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringSpecialSpec();
        	// hasSpecial <==> specialSpec != null (i.e., presence of spec indicates true)
        	if (specialSpec != null) {
        		vDirList.setHasSpecialValue(true);
            	vDirList.setSpecialValue(specialSpec.getstringValue().getSTRING_LITERAL().toString());
        	} else {
        		vDirList.setHasSpecialValue(false);
        		//vString.setSpecialValue(null);
        	}

        	stringDefValueSpec defValueSpec = propSpecs.getstringSpecificSpec().getstringDefValueSpec();
        	if (defValueSpec != null) {
        		vDirList.setDefaultValue(defValueSpec.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	IstringEmptySpec emptyValueSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringEmptySpec();
        	if (emptyValueSpec instanceof stringEmptySpec0) {
        		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
        		vDirList.setEmptyValueAllowed(false);
        		vDirList.setEmptyValue(null);
        	} else if (emptyValueSpec instanceof stringEmptySpec1) {
           		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
        		vDirList.setEmptyValueAllowed(ses1.getEMPTYALLOWED().toString().equals("true"));
        		vDirList.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = pageInfo.getTabInfos();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteDirListFieldInfo cDirList = new ConcreteDirListFieldInfo(vDirList, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cDirList.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cDirList.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(IPreferencesService.DEFAULT_LEVEL))) {
                	cDirList.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cDirList.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cDirList.setHasSpecialValue(true);
                	cDirList.setSpecialValue(specialSpec.getstringValue().getSTRING_LITERAL().toString());
            	} else {
            		cDirList.setHasSpecialValue(false);
            		//cString.setSpecialValue(null);
            	}
            	if (emptyValueSpec != null) {
	            	if (emptyValueSpec instanceof stringEmptySpec0) {
	            		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
	            		cDirList.setEmptyValueAllowed(false);
	            		cDirList.setEmptyValue(null);
	            	} else if (emptyValueSpec instanceof stringEmptySpec1) {
	               		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
	            		cDirList.setEmptyValueAllowed(true);
	            		cDirList.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
	            	}
            	}
        	}
        	return false;
        }
  
        
        public boolean visit(fileFieldSpec fileField) {
        	VirtualFileFieldInfo vFile = new VirtualFileFieldInfo(pageInfo, fileField.getidentifier().toString());
        	fileFieldPropertySpecs propSpecs = fileField.getfileFieldPropertySpecs();
        	
        	// Create a virtual field
            isEditableSpec editableSpec = propSpecs.getgeneralSpecs().getisEditableSpec();
        	if (editableSpec != null) {
        		vFile.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getgeneralSpecs().getisRemovableSpec();
        	if (removableSpec != null) {
            	vFile.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	stringSpecialSpec specialSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringSpecialSpec();
        	// hasSpecial <==> specialSpec != null (i.e., presence of spec indicates true)
        	if (specialSpec != null) {
        		vFile.setHasSpecialValue(true);
            	vFile.setSpecialValue(specialSpec.getstringValue().getSTRING_LITERAL().toString());
        	} else {
        		vFile.setHasSpecialValue(false);
        		//vString.setSpecialValue(null);
        	}

        	stringDefValueSpec defValueSpec = propSpecs.getstringSpecificSpec().getstringDefValueSpec();
        	if (defValueSpec != null) {
        		vFile.setDefaultValue(defValueSpec.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	IstringEmptySpec emptyValueSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringEmptySpec();
        	if (emptyValueSpec instanceof stringEmptySpec0) {
        		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
        		vFile.setEmptyValueAllowed(false);
        		vFile.setEmptyValue(null);
        	} else if (emptyValueSpec instanceof stringEmptySpec1) {
           		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
        		vFile.setEmptyValueAllowed(ses1.getEMPTYALLOWED().toString().equals("true"));
        		vFile.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = pageInfo.getTabInfos();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteFileFieldInfo cFile = new ConcreteFileFieldInfo(vFile, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cFile.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cFile.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(IPreferencesService.DEFAULT_LEVEL))) {
                	cFile.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cFile.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cFile.setHasSpecialValue(true);
                	cFile.setSpecialValue(specialSpec.getstringValue().getSTRING_LITERAL().toString());
            	} else {
            		cFile.setHasSpecialValue(false);
            		//cString.setSpecialValue(null);
            	}
            	if (emptyValueSpec != null) {
	            	if (emptyValueSpec instanceof stringEmptySpec0) {
	            		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
	            		cFile.setEmptyValueAllowed(false);
	            		cFile.setEmptyValue(null);
	            	} else if (emptyValueSpec instanceof stringEmptySpec1) {
	               		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
	            		cFile.setEmptyValueAllowed(true);
	            		cFile.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
	            	}
            	}
        	}
        	return false;
        }
        
        
        
        public boolean visit(intFieldSpec intField) {
        	VirtualIntFieldInfo vInt = new VirtualIntFieldInfo(pageInfo, intField.getidentifier().toString());
        	intFieldPropertySpecs propSpecs = intField.getintFieldPropertySpecs();
        	
        	// Create a virtual field
            isEditableSpec editableSpec = propSpecs.getgeneralSpecs().getisEditableSpec();
        	if (editableSpec != null) {
        		vInt.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getgeneralSpecs().getisRemovableSpec();
        	if (removableSpec != null) {
            	vInt.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	intSpecificSpec specificSpec = propSpecs.getintSpecificSpec();
        	intCustomSpec customSpec = specificSpec.getintCustomSpec();
        	intSpecialSpec specialSpec = customSpec.getintSpecialSpec();
        	intRangeSpec rangeSpec = customSpec.getintRangeSpec();
        	intDefValueSpec defValueSpec = specificSpec.getintDefValueSpec();
        	
        	// hasSpecial <==> specialSpec != null (i.e., presence of spec indicates true)
        	if (specialSpec != null) {
        		vInt.setHasSpecialValue(true);
        		int intValue = 0;
        		IsignedNumber signedNumber = specialSpec.getsignedNumber();
        		if (signedNumber instanceof signedNumber0) {
        			intValue = new Integer(((signedNumber0)signedNumber).getNUMBER().toString()).intValue();
        		} else if (signedNumber instanceof signedNumber1) {
        			intValue = new Integer(((signedNumber1)signedNumber).getNUMBER().toString()).intValue();
        		}
        		vInt.setSpecialValue(intValue);
        	} else {
        		vInt.setHasSpecialValue(false);
        		//vInt.setSpecialValue(null);
        	}

        	if (defValueSpec != null) {
        		int intValue = 0;
        		IsignedNumber signedNumber = defValueSpec.getsignedNumber();
        		if (signedNumber instanceof signedNumber0) {
        			intValue = new Integer(((signedNumber0)signedNumber).getNUMBER().toString()).intValue();
        		} else if (signedNumber instanceof signedNumber1) {
        			intValue = new Integer(((signedNumber1)signedNumber).getNUMBER().toString()).intValue();
        		}
        		vInt.setDefaultValue(intValue);
        	}
        	
        	if (rangeSpec != null) {
        		int intValue = 0;
        		IsignedNumber lower = rangeSpec.getsignedNumber();
        		if (lower instanceof signedNumber0) {
        			intValue = new Integer(((signedNumber0)lower).getNUMBER().toString()).intValue();
        		} else if (lower instanceof signedNumber1) {
        			intValue = new Integer(((signedNumber1)lower).getNUMBER().toString()).intValue();
        		}
        		vInt.setRangeLow(intValue);
        		
        		IsignedNumber upper = rangeSpec.getsignedNumber4();
        		if (upper instanceof signedNumber0) {
        			intValue = new Integer(((signedNumber0)upper).getNUMBER().toString()).intValue();
        		} else if (upper instanceof signedNumber1) {
        			intValue = new Integer(((signedNumber1)upper).getNUMBER().toString()).intValue();
        		}
        		vInt.setRangeHigh(intValue);
        	}
        	
        	
        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = pageInfo.getTabInfos();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteIntFieldInfo cInt = new ConcreteIntFieldInfo(vInt, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cInt.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cInt.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(IPreferencesService.DEFAULT_LEVEL))) {
                	cInt.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cInt.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cInt.setHasSpecialValue(true);
            		int intValue = 0;
            		IsignedNumber signedNumber = specialSpec.getsignedNumber();
            		if (signedNumber instanceof signedNumber0) {
            			intValue = new Integer(((signedNumber0)signedNumber).getNUMBER().toString()).intValue();
            		} else if (signedNumber instanceof signedNumber1) {
            			intValue = new Integer(((signedNumber1)signedNumber).getNUMBER().toString()).intValue();
            		}
            		cInt.setSpecialValue(intValue);
            	} else {
            		cInt.setHasSpecialValue(false);
            		//cString.setSpecialValue(null);
            	}

            	if (rangeSpec != null) {
            		int intValue = 0;
            		IsignedNumber lower = rangeSpec.getsignedNumber();
            		if (lower instanceof signedNumber0) {
            			intValue = new Integer(((signedNumber0)lower).getNUMBER().toString()).intValue();
            		} else if (lower instanceof signedNumber1) {
            			intValue = new Integer(((signedNumber1)lower).getNUMBER().toString()).intValue();
            		}
            		cInt.setRangeLow(intValue);
            		
            		IsignedNumber upper = rangeSpec.getsignedNumber4();
            		if (upper instanceof signedNumber0) {
            			intValue = new Integer(((signedNumber0)upper).getNUMBER().toString()).intValue();
            		} else if (upper instanceof signedNumber1) {
            			intValue = new Integer(((signedNumber1)upper).getNUMBER().toString()).intValue();
            		}
            		cInt.setRangeHigh(intValue);
            	}
            	
        	}
        	return false;
        }
        
        
        
        public boolean visit(stringFieldSpec stringField) {
        	VirtualStringFieldInfo vString = new VirtualStringFieldInfo(pageInfo, stringField.getidentifier().toString());
        	stringFieldPropertySpecs propSpecs = stringField.getstringFieldPropertySpecs();
        	
        	// Create a virtual field
            isEditableSpec editableSpec = propSpecs.getgeneralSpecs().getisEditableSpec();
        	if (editableSpec != null) {
        		vString.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
        	}
        	isRemovableSpec removableSpec = propSpecs.getgeneralSpecs().getisRemovableSpec();
        	if (removableSpec != null) {
            	vString.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
        	}
        	
        	stringSpecialSpec specialSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringSpecialSpec();
        	// hasSpecial <==> specialSpec != null (i.e., presence of spec indicates true)
        	if (specialSpec != null) {
        		vString.setHasSpecialValue(true);
            	vString.setSpecialValue(specialSpec.getstringValue().getSTRING_LITERAL().toString());
        	} else {
        		vString.setHasSpecialValue(false);
        		//vString.setSpecialValue(null);
        	}

        	stringDefValueSpec defValueSpec = propSpecs.getstringSpecificSpec().getstringDefValueSpec();
        	if (defValueSpec != null) {
        		vString.setDefaultValue(defValueSpec.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	IstringEmptySpec emptyValueSpec = propSpecs.getstringSpecificSpec().getstringCustomSpec().getstringEmptySpec();
        	if (emptyValueSpec instanceof stringEmptySpec0) {
        		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
        		vString.setEmptyValueAllowed(false);
        		vString.setEmptyValue(null);
        	} else if (emptyValueSpec instanceof stringEmptySpec1) {
           		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
        		vString.setEmptyValueAllowed(ses1.getEMPTYALLOWED().toString().equals("true"));
        		vString.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
        	}
        	
        	// Create an instance of a concrete field for each tab on the page
        	Iterator tabs = pageInfo.getTabInfos();
        	while (tabs.hasNext()) {
        		PreferencesTabInfo tab = (PreferencesTabInfo) tabs.next();
        		if (!tab.getIsUsed())
        			continue;
        		ConcreteStringFieldInfo cString = new ConcreteStringFieldInfo(vString, tab);
        		
        		// Set the attributes of the concrete field:
        		// if set in the virtual field, use that value;
        		// else if set for the tab, use that value;
        		// else rely on the default for the field type
            	if (editableSpec != null) {
            		cString.setIsEditable(editableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cString.setIsEditable(tab.getIsEditable());
            	}
            	if (removableSpec != null && !(tab.getName().equals(IPreferencesService.DEFAULT_LEVEL))) {
                	cString.setIsRemovable(removableSpec.getbooleanValue().toString().equals("true"));
            	} else {
            		cString.setIsRemovable(tab.getIsRemovable());
            	}
            	if (specialSpec != null) {
            		cString.setHasSpecialValue(true);
                	cString.setSpecialValue(specialSpec.getstringValue().getSTRING_LITERAL().toString());
            	} else {
            		cString.setHasSpecialValue(false);
            		//cString.setSpecialValue(null);
            	}
            	if (emptyValueSpec != null) {
	            	if (emptyValueSpec instanceof stringEmptySpec0) {
	            		stringEmptySpec0 ses0 = (stringEmptySpec0) emptyValueSpec;
	            		cString.setEmptyValueAllowed(false);
	            		cString.setEmptyValue(null);
	            	} else if (emptyValueSpec instanceof stringEmptySpec1) {
	               		stringEmptySpec1 ses1 = (stringEmptySpec1) emptyValueSpec;
	            		cString.setEmptyValueAllowed(true);
	            		cString.setEmptyValue(ses1.getstringValue().getSTRING_LITERAL().toString());
	            	}
            	}
        	}
        	return false;
        }
        
        
        
        
        /*
         * Context for processing of custom rules 
         */ 
        String customTabName = null;
        PreferencesTabInfo customTabInfo = null;
        String customFieldName = null;
        ConcreteFieldInfo customFieldInfo = null;
        
        
        public boolean visit(customRule custRule)
        {
        	// Set context for custom spec processing
        	customTabName = custRule.gettab().toString();
        	customFieldName = custRule.getidentifier().toString();
        	
        	customTabInfo = pageInfo.getTabInfo(customTabName);
        	Iterator concreteFields = customTabInfo.getConcreteFields();
        	// Should always have a field with the given name
        	while (concreteFields.hasNext()) {
        		ConcreteFieldInfo next = (ConcreteFieldInfo) concreteFields.next();
        		if (next.getName().equals(customFieldName)) {
        			customFieldInfo = next;
        			break;
        		}	
        	}
        	if (customFieldInfo == null) {
        		// What to do?  Seems that specification is erroneous
        		System.err.println("PrefspecsCompiler.TranslatorVisitor.visit(customRule):\n    found no field info corresponding to field name = '" +
        				customFieldName + "';\n    continuing at your own risk");
        	}
        	
        	return true;
        }
        
        
        public void endVisit(customRule custRule)
        {
        	// Reset context of custom spec processing
        	customTabName = null;
        	customTabInfo = null;
        	customFieldName = null;
        	customFieldInfo = null;	
        }
        

        // Use endVisit(..) methods to get information from specs because when
        // visit(..)ed they don't yet have the info that's needed
        
        
        public void endVisit(generalSpecs genSpecs)
        {
        	// Process general spec as part of a custom rule,
        	// if processing a custom rule
        	if (customTabName != null) {
        		if (genSpecs.getisEditableSpec() != null)
	        		customFieldInfo.setIsEditable(genSpecs.getisEditableSpec().getbooleanValue().toString().equals("true"));
        		try {
        			if (genSpecs.getisRemovableSpec() != null)
        				customFieldInfo.setIsRemovable(genSpecs.getisRemovableSpec().getbooleanValue().toString().equals("true"));
        		} catch (IllegalArgumentException e) {
        			System.err.println("PrefspecsCompiler.TranslatorVisitor.visit(generalSpecs:  \n" +
        					"\tattempt to set isRemovable to illegal value 'true'; substituting 'false'.");
        			customFieldInfo.setIsRemovable(false);
        		}
        	}
        }
        
        
        public void endVisit(booleanSpecialSpec specialSpec)
        {
        	// Process special spec as part of a boolean custom spec,
        	// if processing a custom rule
        	// If the specialSpec is not null, then the field has a special spec
        	// and the value of that spec is the special value for the field
        	if (customTabName != null) {
        		// Don't think the boolean value can be null if we have a specialSpec	
        		((ConcreteBooleanFieldInfo)customFieldInfo).setSpecialValue(specialSpec.getbooleanValue().toString().equals("true"));
        	}
        }
        
        
        public void endVisit(stringSpecialSpec specialSpec)
        {
        	// Process special spec as part of a string custom spec,
        	// if processing a custom rule
        	// If the specialSpec is not null, then the field has a special spec
        	// and the value of that spec is the special value for the field
        	if (customTabName != null) {
        		// Don't think the boolean value can be null if we have a specialSpec	
        		((ConcreteStringFieldInfo)customFieldInfo).setSpecialValue(specialSpec.getstringValue().getSTRING_LITERAL().toString());
        	}
        }
        

        
        /*
         * For processing of conditional rules
         */
        
        /*
         * For "with" condition rules
         */
        public boolean visit(conditionalSpec0 rule) {
        	
        	String conditionalFieldName = rule.getidentifier().toString();
        	String conditionFieldName = rule.getidentifier3().toString();
        	VirtualFieldInfo conditionalFieldInfo = null;
        	VirtualFieldInfo conditionFieldInfo = null;
        	
        	Iterator virtualFieldInfos = pageInfo.getVirtualFieldInfos();	
        	while (virtualFieldInfos.hasNext()) {
        		VirtualFieldInfo next = (VirtualFieldInfo) virtualFieldInfos.next();
        		String nextName = next.getName();
        		if (nextName.equals(conditionalFieldName)) {
        			conditionalFieldInfo = next;
        		} else if (nextName.equals(conditionFieldName)) {
        			conditionFieldInfo = next;
        		}
        		if (conditionalFieldInfo != null && conditionFieldInfo != null)
        			break;
        	}
        	conditionalFieldInfo.setIsConditional(true);
        	conditionalFieldInfo.setConditionalWith(true);
        	// if we're compiling, then the AST should be correct,
        	// in which case the condition field should always be
        	// a boolean field
        	conditionalFieldInfo.setConditionField((VirtualBooleanFieldInfo)conditionFieldInfo);
        	
        	return false;
        }
        
        
        /*
         * For "against" condition rules
         */
        public boolean visit(conditionalSpec1 rule) {
        	
        	String conditionalFieldName = rule.getidentifier().toString();
        	String conditionFieldName = rule.getidentifier3().toString();
        	VirtualFieldInfo conditionalFieldInfo = null;
        	VirtualFieldInfo conditionFieldInfo = null;
        	
        	Iterator virtualFieldInfos = pageInfo.getVirtualFieldInfos();	
        	while (virtualFieldInfos.hasNext()) {
        		VirtualFieldInfo next = (VirtualFieldInfo) virtualFieldInfos.next();
        		String nextName = next.getName();
        		if (nextName.equals(conditionalFieldName)) {
        			conditionalFieldInfo = next;
        		} else if (nextName.equals(conditionFieldName)) {
        			conditionFieldInfo = next;
        		}
        		if (conditionalFieldInfo != null && conditionFieldInfo != null)
        			break;
        	}
        	conditionalFieldInfo.setIsConditional(true);
        	conditionalFieldInfo.setConditionalWith(false);
        	// if we're compiling, then the AST should be correct,
        	// in which case the condition field should always be
        	// a boolean field
        	conditionalFieldInfo.setConditionField((VirtualBooleanFieldInfo)conditionFieldInfo);
        	
        	return false;
        }
        
        
        
        public void endVisit(conditionalSpecs0 spec) {
        	propagateConditionsToConcreteSpecs();
        }
        
        
        public void endVisit(conditionalSpecs1 spec) {
        	propagateConditionsToConcreteSpecs();
        }
        
        
        protected void propagateConditionsToConcreteSpecs()
        {
        	Iterator vFieldInfos = pageInfo.getVirtualFieldInfos();
        	while (vFieldInfos.hasNext()) {
        		VirtualFieldInfo vInfo = (VirtualFieldInfo) vFieldInfos.next();
        		if (vInfo.getIsConditional()) {
        			Iterator cFieldInfos = vInfo.getConcreteFieldInfos();
        			while (cFieldInfos.hasNext()) {
        				ConcreteFieldInfo cInfo = (ConcreteFieldInfo) cFieldInfos.next();
        				cInfo.setIsConditional(true);
        				cInfo.setConditionalWith(vInfo.getConditionalWith());
        				cInfo.setConditionField(vInfo.getConditionField());
        			}
        		}
        	}
        	
        	
        }
        
        
        
        
        
        
    }

    
    
    public PrefspecsCompiler() {
        super();
    }

    public String getFileContents(IFile file) {
        char[] buf= null;
        try {
            File javaFile= new File(file.getLocation().toOSString());
            FileReader fileReader= new FileReader(javaFile);
            int len= (int) javaFile.length();

            buf= new char[len];
            fileReader.read(buf, 0, len);
            return new String(buf);
        } catch(FileNotFoundException fnf) {
            System.err.println(fnf.getMessage());
            return "";
        } catch(IOException io) {
            System.err.println(io.getMessage());
            return "";
        }
    }

    public PreferencesPageInfo compile(IFile file, IProgressMonitor mon) {
       	
    	if (file == null) {
            System.err.println("PrefspecsCompiler.compile(..):  returning null");
    		return null;
    	}
    	IProject project= file.getProject();
    	if (project == null) {
            System.err.println("PrefspecsCompiler.compile(..):  Project is null; returning null");
    		return null;
    	}
		ISourceProject sourceProject = null;
    	try {
    		sourceProject = ModelFactory.open(project);
    	} catch (ModelException me){
            System.err.println("PrefspecsCompiler.compile(..):  Model exception:\n" + me.getMessage() + "\nReturning null");
            return null;
    	}
        IParseController parseController= new PrefspecsParseController();
        
        // Marker creator handles error messages from the parse controller
        MarkerCreator markerCreator = new MarkerCreator(file, parseController, PROBLEM_MARKER_ID);

        // If we have a kind of parser that might be receptive, tell it
        // what types of problem marker the builder will create
        parseController.addProblemMarkerType(PROBLEM_MARKER_ID);
        
        parseController.initialize(file.getProjectRelativePath(), sourceProject, markerCreator);

        parseController.parse(getFileContents(file), false, mon);

        ASTNode currentAst= (ASTNode) parseController.getCurrentAst();

        if (currentAst == null) {
            System.err.println("PrefspecsCompiler.compile:  current AST is null (parse errors?); unable to compile.");
        	return null;
        }

        String fileExten= file.getFileExtension();
        String fileBase= file.getName().substring(0, file.getName().length() - fileExten.length() - 1);

        TranslatorVisitor visitor = new TranslatorVisitor();
        
        currentAst.accept(visitor);

        return pageInfo;

    }
    
    public PreferencesPageInfo getPageInfo(IFile file, IProgressMonitor mon) {

       	if (file == null) {
            System.err.println("PrefspecsCompiler.getPageInfo(..):  returning null");
    		return null;
    	}
    	IProject project= file.getProject();
    	if (project == null) {
            System.err.println("PrefspecsCompiler.getPageInfo(..):  Project is null; returning null");
    		return null;
    	}
		ISourceProject sourceProject = null;
    	try {
    		sourceProject = ModelFactory.open(project);
    	} catch (ModelException me){
            System.err.println("PrefspecsCompiler.getPageInfo(..):  Model exception:\n" + me.getMessage() + "\nReturning null");
            return null;
    	}
        IParseController parseController= new PrefspecsParseController();
        
        // Marker creator handles error messages from the parse controller
        MarkerCreator markerCreator = new MarkerCreator(file, parseController, PROBLEM_MARKER_ID);

        // If we have a kind of parser that might be receptive, tell it
        // what types of problem marker the builder will create
        parseController.addProblemMarkerType(PROBLEM_MARKER_ID);
        
        parseController.initialize(file.getProjectRelativePath(), sourceProject, markerCreator);
    	
    	parseController.parse(getFileContents(file), false, mon);

        ASTNode currentAst= (ASTNode) parseController.getCurrentAst();

        if (currentAst == null) {
            System.err.println("PrefspecsCompiler.getPageInfo	:  current AST is null (parse errors?); unable to compile.");
        	return null;
        }

        String fileExten= file.getFileExtension();
        String fileBase= file.getName().substring(0, file.getName().length() - fileExten.length() - 1);

        TranslatorVisitor translatorVisitor = new TranslatorVisitor();
        currentAst.accept(translatorVisitor);

        return getPreferencesPageInfo();
        
    }
}
